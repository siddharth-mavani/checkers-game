typedef struct Node{
    int Num_B_Capture ;
    int Num_W_Capture ; 
    Game_Spec* G ;
} Vertex;


void copy(int v[8][8], int u [8][8])
{
    for (int i = 0 ; i < 8 ; i = i + 1)
    {
        for (int j = 0 ; j < 8 ; j = j + 1)
        {
            v[i][j] = u[i][j] ;
        }
    }

    return ;
}

void move (int u[8][8], int row,int colm,int row_new ,int colm_new)
{
    if (abs(row_new - row) == 1)
    {
        u[row_new][colm_new] = u[row][colm] ;
        u[row][colm] = 0 ;
    }

    if (abs(row_new - row) == 2)
    {
        u[row_new][colm_new] = u[row][colm] ;
        u[row][colm] = 0 ;
        u[ ( row + row_new ) / 2][ ( colm + colm_new ) / 2] = 0 ;
    }

    return ;
}


int Change_To_King (int u[8][8], int player,int FinalRow, int InitialRow, int InitialColm, Vertex* V )
{   
    int change = 0;
        
    if (FinalRow == 0 && u[InitialRow][InitialColm] == WHITE)
    {
        u[InitialRow][InitialColm] = WHITE_KING;
        change = 1;
        V->G->Num_White_King++;
    }
    
    if (FinalRow == 7 && u[InitialRow][InitialColm] == BLACK)
    {
        u[InitialRow][InitialColm] = BLACK_KING;
        change = 1;
        V->G->Num_Black_King++;
       }

    return change ;
}


// after every move have to check if the game has ended.. -- Done
// need to keep int no of moves with final no of moves for the print_sequence function..
// need to convert to kings.. -- Done
void Print_K_Moves(int u[8][8], int player, int k, int count, Vertex* V)
{
    int v[8][8] = {0} ;
    int change = 0;

    if (endgame(V->G,u,player) == true)
    {
        Print_Board(u,V->G,player) ;
        return ;
    }
    

    for (int row = 0 ; row < 8 ; row = row + 1)
    {
        for (int colm = 0 ; colm < 8 ; colm = colm + 1)
        {
            if (player * u[row][colm] > 0)
            {   
                if (count != 2)
                {

                

                if (CheckMove(u,row,colm,row+1,colm+1,0,player))
                {
                        copy(v,u) ;// copies the state of board from u to v
                        move(v,row,colm,row+1,colm+1) ; // moves the piece from row,colm, to the next place

                        change = Change_To_King(u,player,row+1,row,colm,V) ;
                        Insert_move(V->G,colm,colm+1,row,row+1,u[row][colm] , 0,0, change) ;

                    if ( k != 1)
                    {
                        Print_K_Moves(v,-player,k-1,0,V) ;
                    }

                    if (k == 1)
                    {
                        Print_Board(v, V->G , player) ;// printing board
                        Undo(v,V->G) ; //used to go back to last move
                        return ;
                    }
                }

                if (CheckMove(u,row,colm,row-1,colm-1,0,player))
                {
                        copy(v,u) ;// copies the state of board from u to v
                        move(v,row,colm,row-1,colm-1) ; // moves the piece from row,colm, to the next place

                        change = Change_To_King(u,player,row-1,row,colm,V) ;
                        Insert_move(V->G,colm,colm-1,row,row-1,u[row][colm] , 0,0,change) ;

                    if ( k != 1)
                    {
                        Print_K_Moves(v,-player,k-1,0,V) ;
                    }

                    if (k == 1)
                    {
                        Print_Board(v, V->G, player) ;// printing board
                        Undo(v,V->G) ;//used to go back to last move
                        return ;
                    }
                }

                if (CheckMove(u,row,colm,row+1,colm-1,0,player))
                {
                        copy(v,u) ;// copies the state of board from u to v
                        move(v,row,colm,row+1,colm-1) ; // moves the piece from row,colm, to the next place

                        change = Change_To_King(u,player,row+1,row,colm,V) ;
                        Insert_move(V->G,colm,colm-1,row,row+1,u[row][colm] , 0,0,change) ;

                    if ( k != 1)
                    {
                        Print_K_Moves(v,-player,k-1,0,V) ;
                    }

                    if (k == 1)
                    {
                        Print_Board(v, V->G, player) ;// printing board
                        Undo(v,V->G) ;//used to go back to last move
                        return ;
                    }
                }


                if (CheckMove(u,row,colm,row-1,colm+1,0,player))
                {
                        copy(v,u) ;// copies the state of board from u to v
                        move(v,row,colm,row-1,colm + 1) ; // moves the piece from row,colm, to the next place

                        change = Change_To_King(u,player,row-1,row,colm,V) ;
                        Insert_move(V->G,colm,colm+1,row,row-1, u[row][colm], 0,0,change) ;

                    if ( k != 1)
                    {
                        Print_K_Moves(v,-player,k-1,0,V) ;
                    }

                    if (k == 1)
                    {
                        Print_Board(v,V->G , player) ;// printing board
                        Undo(v,V->G) ;//used to go back to last move
                        return ;
                    }
                }

                }
            

                    if (CheckMove(u,row,colm,row+2,colm+2,0,player) > 0)
                    {
                        copy(v,u) ;
                        move (v,row,colm,row+2,colm+2) ;
                        change = Change_To_King(u,player,row+2,row,colm,V) ;
                        Insert_move(V->G,colm,colm+2,row,row+2,u[row][colm] ,1,u[(row + row + 2) / 2][(colm + colm + 2) / 2],change) ;
                        
                        count = 2 ;

                        Print_K_Moves(v,player,k,count,V) ;
                    }


                    if (CheckMove(u,row,colm,row-2,colm-2, 0 , player) > 0)
                    {
                        copy(v,u) ;
                        move (v,row,colm,row-2,colm-2) ;
                        change = Change_To_King(u,player,row-2,row,colm,V) ;
                        Insert_move(V->G,colm,colm-2,row,row-2, u[row][colm], 1,u[(row + row - 2) / 2][(colm + colm - 2) / 2],change) ;

                        count = 2 ;

                        Print_K_Moves(v,player,k,count,V) ;
                    }

                    
                    if (CheckMove(u,row,colm,row+2,colm-2, 0 , player) > 0)
                    {
                        copy(v,u) ;
                        move (v,row,colm,row+2,colm-2) ;
                        change = Change_To_King(u,player,row+2,row,colm,V) ;
                        Insert_move(V->G,colm,colm-2,row,row+2,u[row][colm] , 1,u[(row + row + 2) / 2][(colm + colm - 2) / 2], change) ;

                        count = 2 ;

                        Print_K_Moves(v,player,k,count,V) ;
                    }


                    if (CheckMove(u,row,colm,row-2,colm+2, 0 ,player) > 0)
                    {
                        copy(v,u) ;
                        move (v,row,colm,row-2,colm+2) ;
                        change = Change_To_King(u,player,row-2,row,colm,V) ;
                        Insert_move(V->G,colm,colm+2,row,row-2, u[row][colm], 1,u[(row + row -2) / 2 ][ ( colm + colm + 2 ) / 2],change) ;

                        count = 2 ;

                        Print_K_Moves(v,player,k,count,V) ;
                    }


                    if (count == 2)                        // used to decide when to make next move in case of multiple capture..
                    {
                        copy(v,u) ;
                        // no need to check for king as it is already done in the previous step
                        Insert_move(V->G,colm,colm+1,row,row+1,u[row][colm] , 0,0, 0) ;

                        if (k != 1)
                        {
                            Print_K_Moves(v,-player,k-1,0,V) ;
                        }

                        if (k == 1)
                        {
                            Print_Board(v,V->G , player) ;// printing board
                        }
                    }

            }
        }
    }

    Undo(v,V->G) ; //used to go back to last move ;
    return ;  

}

void Next_K_Moves(int u[8][8], int player,int k ,Game_Spec* G)
{
    Vertex* V = (Vertex*) malloc (sizeof(Vertex)) ;

    V->Num_B_Capture = 0;
    V->Num_W_Capture = 0;
    V->G = G ;

    Print_K_Moves(u,player,k,0,V) ;

    return ;

}
